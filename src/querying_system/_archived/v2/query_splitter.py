"""
Query Splitter Agent.

Takes a question and its decomposition, uses LLM to explicitly split
into independent sub-queries for parallel retrieval.

Runs AFTER decomposition to generate targeted search queries.
"""

import asyncio
import os
import time
from typing import Optional

from pydantic import BaseModel, Field

from src.querying_system.shared.schemas import QueryDecomposition, SubQuery, EntityHint
from src.util.llm_client import get_critique_llm

VERBOSE = os.getenv("VERBOSE", "false").lower() == "true"


def log(msg: str):
    if VERBOSE:
        print(f"[QuerySplitter] {msg}")


class GeneratedSubQuery(BaseModel):
    """A sub-query generated by the splitter."""
    query_text: str = Field(..., description="Focused search query text")
    target_info: str = Field(..., description="What this sub-query aims to find")
    relevant_entities: list[str] = Field(
        default_factory=list,
        description="Entity names from decomposition that this sub-query targets"
    )
    relevant_topics: list[str] = Field(
        default_factory=list,
        description="Topic names from decomposition that this sub-query targets"
    )


class SplitResult(BaseModel):
    """Output from the query splitter."""
    sub_queries: list[GeneratedSubQuery] = Field(
        default_factory=list,
        description="Independent sub-queries for parallel retrieval"
    )
    reasoning: str = Field(
        default="",
        description="Explanation of how the question was split"
    )


SPLITTER_SYSTEM_PROMPT = """You are a query splitting agent. Your job is to break down a question into independent sub-queries for parallel knowledge graph retrieval.

INPUTS YOU RECEIVE:
- The original question
- Extracted entities (things mentioned in the question)
- Extracted topics (concepts/themes in the question)
- Question type classification

YOUR TASK:
Generate independent sub-queries that can be executed in parallel. Each sub-query should:
1. Be self-contained and focused on finding specific information
2. Target specific entities or topics from the decomposition
3. Use keyword-style phrasing (not full sentences)

SPLITTING RULES:
- If the question asks about multiple entities, create a sub-query per entity
- If the question asks about multiple aspects/topics, create a sub-query per aspect
- If the question compares things, create separate sub-queries for each thing being compared
- If the question has temporal aspects, include the time reference in relevant sub-queries
- Simple questions may only need 1-2 sub-queries
- Complex questions may need 3-5 sub-queries

QUERY TEXT GUIDELINES:
- Use keywords and short phrases, not full questions
- Combine entity names with topic/relationship terms
- Include temporal references when relevant
- Keep queries concise but specific

OUTPUT:
Generate sub-queries that together would retrieve all information needed to answer the original question."""


SPLITTER_USER_PROMPT = """ORIGINAL QUESTION: {question}

DECOMPOSITION:
- Question Type: {question_type}
- Entities: {entities}
- Topics: {topics}
- Temporal Scope: {temporal_scope}
- Required Information: {required_info}

Split this question into independent sub-queries for parallel retrieval. Each sub-query should target specific entities/topics and be executable independently."""


class QuerySplitter:
    """
    Splits a question into independent sub-queries using an LLM.

    Flow:
    1. Takes question + decomposition as input
    2. LLM generates independent sub-queries
    3. Each sub-query maps to relevant entities/topics
    """

    def __init__(self, llm=None):
        if llm is None:
            llm = get_critique_llm()
        self.llm = llm
        self.structured_splitter = llm.with_structured_output(SplitResult)

    async def split(
        self,
        question: str,
        decomposition: QueryDecomposition,
    ) -> tuple[list[SubQuery], int]:
        """
        Split a question into independent sub-queries.

        Args:
            question: Original user question
            decomposition: Output from the decomposer

        Returns:
            tuple of (list[SubQuery], elapsed_time_ms)
        """
        start_time = time.time()
        log(f"Splitting question: {question}")

        # Format decomposition for the prompt
        entities = [
            h.name if isinstance(h, EntityHint) else h
            for h in decomposition.entity_hints
        ]
        topics = [
            h.name if isinstance(h, EntityHint) else h
            for h in decomposition.topic_hints
        ]

        prompt = SPLITTER_USER_PROMPT.format(
            question=question,
            question_type=decomposition.question_type.value,
            entities=", ".join(entities) if entities else "None extracted",
            topics=", ".join(topics) if topics else "None extracted",
            temporal_scope=decomposition.temporal_scope or "Not specified",
            required_info="; ".join(decomposition.required_info) if decomposition.required_info else "Not specified",
        )

        try:
            result = await asyncio.to_thread(
                self.structured_splitter.invoke,
                [
                    ("system", SPLITTER_SYSTEM_PROMPT),
                    ("human", prompt),
                ]
            )

            elapsed = int((time.time() - start_time) * 1000)

            # Convert to SubQuery format
            sub_queries = [
                SubQuery(
                    query_text=sq.query_text,
                    target_info=sq.target_info,
                    entity_hints=sq.relevant_entities,
                    topic_hints=sq.relevant_topics,
                )
                for sq in result.sub_queries
            ]

            log(f"Split into {len(sub_queries)} sub-queries in {elapsed}ms")
            for sq in sub_queries:
                log(f"  - {sq.query_text} (targets: {sq.entity_hints})")

            return sub_queries, elapsed

        except Exception as e:
            log(f"Split error: {e}, using fallback")
            elapsed = int((time.time() - start_time) * 1000)
            return self._create_fallback(question, decomposition), elapsed

    def _create_fallback(
        self,
        question: str,
        decomposition: QueryDecomposition,
    ) -> list[SubQuery]:
        """Fallback: create simple sub-queries from decomposition."""
        sub_queries = []

        # Create one sub-query per entity
        for hint in decomposition.entity_hints:
            name = hint.name if isinstance(hint, EntityHint) else hint
            sub_queries.append(SubQuery(
                query_text=f"{name} {question}",
                target_info=f"Information about {name}",
                entity_hints=[name],
                topic_hints=[
                    h.name if isinstance(h, EntityHint) else h
                    for h in decomposition.topic_hints
                ],
            ))

        # If no entities, use the original question
        if not sub_queries:
            sub_queries.append(SubQuery(
                query_text=question,
                target_info="Answer to the question",
                entity_hints=[],
                topic_hints=[
                    h.name if isinstance(h, EntityHint) else h
                    for h in decomposition.topic_hints
                ],
            ))

        return sub_queries
